// John Dale Datetime (JDDT)

const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
const TODAY = 'Today';
// const YESTERDAY = 'Yesterday';
// const TOMORROW = 'Tomorrow';
const SOME_SUNNY_DAY = '';
let serverTimezoneOffset = 0; // Offset in minutes, can by updated by server
let serverTimezoneName = 'GMT'; // Also to be supplied by server

/**
 * Returns number n as string with extra 0 prepended if it's only 1 digit
 * @private
 * @param {number} n
 * @returns {string}
 */
function pad0(n) {
  return n < 10 ? `0${n}` : n.toString();
}

/**
 * Returns number with "st", "nd", "rd" or "th" as appropriate
 * @private
 * @param {number} n
 * @returns {string}
 */
function th(n) {
  if (n > 10 && n < 21) {
    return `${n}th`;
  }
  const lastDigit = n % 10;
  if (lastDigit === 1) {
    return `${n}st`;
  }
  if (lastDigit === 2) {
    return `${n}nd`;
  }
  if (lastDigit === 3) {
    return `${n}rd`;
  }
  return `${n}th`;
}

/**
 * Copy a date, preserving anything generated by timezone offset
 * @private
 * @param {Date} d
 * @returns {Date}
 */
function cloneDate(d) {
  return new Date(
    d.getFullYear(),
    d.getMonth(),
    d.getDate(),
    d.getHours(),
    d.getMinutes(),
    d.getSeconds(),
    d.getMilliseconds(),
  );
}

/**
 * Do the two dates provided match in terms of year, month and date?
 * @private
 * @param {Date} date1
 * @param {Date} date2
 * @returns {boolean}
 */
function datesMatch(date1, date2) {
  return (date1.getDate() === date2.getDate()
  && date1.getMonth() === date2.getMonth()
  && date1.getFullYear() === date2.getFullYear());
}

/**
 * Returns one of the variables named as YESTERDAY, TODAY, TOMORROW or SOME_SUNNY_DAY above
 * @private
 * @param {Date} date
 * @returns {string} - "yesterday", "today", "tomorrow" or "" if it's none of those
 */
function relativeDateName(date) {
  const now = new Date(Date.now());
  const d = cloneDate(date);

  if (datesMatch(now, d)) {
    return TODAY;
  }

  // d.setHours(d.getHours() + 24);
  // if (datesMatch(now, d)) {
  //   return YESTERDAY;
  // }
  //
  // d.setHours(d.getHours() - 48);
  // if (datesMatch(now, d)) {
  //   return TOMORROW;
  // }

  return SOME_SUNNY_DAY;
}

// Get nice local timezone name if it exists
let localTimezoneName;
if (Intl !== undefined && Intl.DateTimeFormat !== undefined) {
  const dtf = Intl.DateTimeFormat();
  if (dtf.resolvedOptions !== undefined && dtf.resolvedOptions().timeZone !== undefined) {
    localTimezoneName = dtf.resolvedOptions().timeZone;
  }
}

/**
 * Generates long/short JDDT format with timezoneName appended
 * @private
 * @static
 * @param {Date} date - js Date object to format
 * @param {string} timezoneName - name of timezone to be appended
 * @param {boolean} [short] - if this is true the function will return truncated
 * months, days and years
 * @returns {string}
 */
function stringify(date, timezoneName, short) {
  const currentYear = new Date(Date.now()).getFullYear();
  let dateName = relativeDateName(date);
  if (dateName === '') {
    let yearString = "";
    if (date.getFullYear() !== currentYear) {
      yearString = ` ${short ? `'${date.getFullYear().toString().substring(2, 4)}` : date.getFullYear().toString()}`;
    }
    dateName = `${short ? days[date.getDay()].substring(0, 3) : days[date.getDay()]} \
    ${th(date.getDate())} \
    ${short ? months[date.getMonth()].substring(0, 3) : months[date.getMonth()]}${yearString}, `;
  }
  return `<i class="fad fa-clock fa-fw" aria-hidden="true"></i> \
    ${dateName} ${pad0(date.getHours())}:${pad0(date.getMinutes())} \
    <span class="text-muted">${timezoneName}</span>`;
}

/**
 * John Dale Datetime object. Handles converts dates to local, JD-style format.
 */
export default class JDDT {
  /**
   * John Dale Datetime object constructor. Works with anything accepted by a plain JS Date object.
   * @constructor
   * @param {Date|number|string} input - accepts a Date, a number of epoch milliseconds
   * or a suitably formatted string
   */
  constructor(input) {
    if (input instanceof Date) {
      this.jsDateLocal = input;
    } else {
      this.jsDateLocal = new Date(input);
    }

    this.localTimezoneOffset = this.jsDateLocal.getTimezoneOffset();

    // For users on old rubbish browsers fall back to +/- mm:hh for timezone name
    if (localTimezoneName === undefined) {
      localTimezoneName = `${this.localTimezoneOffset < 0 ? '-' : '+'}\
        ${pad0(Math.floor(Math.abs(this.localTimezoneOffset / 60)))}:\
        ${pad0(Math.abs(this.localTimezoneOffset) % 60)}`;
    }

    if (typeof this.jsDateLocal.getMonth !== 'function') {
      throw new Error(`Invalid date input: ${input.toString()}`);
    }

    this.jsDateGMT = new Date(this.jsDateLocal.valueOf());
    this.jsDateGMT.setMinutes(this.jsDateLocal.getMinutes() + this.localTimezoneOffset);

    this.jsDateServer = new Date(this.jsDateGMT.valueOf());
    this.jsDateServer.setMinutes(this.jsDateGMT.getMinutes() + serverTimezoneOffset);
  }

  /**
   * Generates long-format string of local datetime
   * - e.g. 17:00 Shanghai / Pacific time, Thursday 19th March 2020
   * @returns {string}
   */
  longLocal() {
    return stringify(this.jsDateLocal, localTimezoneName);
  }

  /**
   * Generates long-format string of GMT datetime
   * - e.g. 12:00 GMT, Thursday 19th March 2020
   * @returns {string}
   */
  longGMT() {
    return stringify(this.jsDateGMT, 'GMT');
  }

  /**
   * Generates long-format string of the server timezone datetime, which can be set using
   * JDDT.setServerTimezone
   * - e.g. 12:00 London/Europe, Thursday 19th March 2020
   * @returns {string}
   */
  longServerTime() {
    return stringify(this.jsDateServer, serverTimezoneName);
  }

  /**
   * Generates short-format string of local datetime
   * - e.g. 17:00 Shanghai / Pacific time, Thu 19th Mar '20
   * @returns {string}
   */
  shortLocal() {
    return stringify(this.jsDateLocal, localTimezoneName, true);
  }

  /**
   * Generates short-format string of GMT datetime
   * - e.g. 12:00 GMT, Thu 19th Mar '20
   * @returns {string}
   */
  shortGMT() {
    return stringify(this.jsDateGMT, 'GMT', true);
  }

  /**
   * Generates a short-format string of server timezone datetime, which can be set using
   * JDDT.setServerTimezone
   * @returns {string}
   */
  shortServerTime() {
    return stringify(this.jsDateServer, serverTimezoneName, true);
  }

  /**
   * Takes an element of the format <span class="jddt" millis="[milliseconds]"
   * format="[validFormat]"></span> and populates its innerHTML with the JDDT
   * @private
   * @static
   * @param {Element} el
   */
  static applyToElement(el) {
    if (!el.hasAttribute('servertimezoneoffset') || !el.hasAttribute('servertimezonename')) {
      throw new Error('Element with .jddt class did not have servertimezoneoffset and servertimezonename attributes')
    }
    this.setServerTimezone(parseInt(el.getAttribute('servertimezoneoffset')), el.getAttribute('servertimezonename'))
    const millis = parseInt(el.getAttribute('millis'), 10);
    const format = el.hasAttribute('format')
      ? el.getAttribute('format')
      : 'longLocal';

    if (typeof JDDT.prototype[format] !== 'function') {
      throw new Error(`Invalid JDDT format specified on element: ${format}`);
    }

    const jddt = new JDDT(millis);
    // eslint-disable-next-line no-param-reassign
    el.innerHTML = jddt[format]();
  }

  /**
   * Looks for anything of the format <span class='jddt' millis='[epochmillis]'
   * format='[validformat]'> and populates its innertext with the formatted date
   * @param {Node} container
   */
  static initialise(container) {
    if (typeof MutationObserver !== 'undefined') {
      // Should exist in IE11
      const observer = new MutationObserver((objects) => {
        // expect Babel for this
        objects.forEach((mutationRecord) => {
          if (mutationRecord.type === 'childList') {
            for (let i = 0; i < mutationRecord.target.children.length; i += 1) {
              mutationRecord.target.children[i].querySelectorAll('span.jddt[millis]')
                .forEach((jddtElement) => {
                  this.applyToElement(jddtElement);
                });
            }
          }
        });
      });
      observer.observe(container, {
        childList: true,
        subtree: true,
      });
    } else {
      // IE9 +
      document.addEventListener('DOMContentLoaded', () => {
        document.querySelectorAll('span.jddt[millis]').forEach((jddtElement) => {
          this.applyToElement(jddtElement);
        });
      });
    }
  }

  /**
   * Updates the server timezone, used in calculating formatted server time
   * @static
   * @param {number} offset - the offset in minutes, in the style of js Date object timezoneOffset
   * @param {string} name - the name of the server timezone (e.g. Europe/London)
   */
  static setServerTimezone(offset, name) {
    if (typeof offset === 'number' && typeof name === 'string') {
      serverTimezoneOffset = offset;
      serverTimezoneName = name;
    } else {
      throw new Error('Provide an offset in number of minutes, and a string of the timezone name');
    }
  }
}
